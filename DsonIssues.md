# Dson设计中的一些反思

Q：为什么数字的解析默认只有double？  
A：**确定性的解析结果很重要**。浮点数可能恰好是一个整数，一个值，一会儿解析成浮点数，一会儿解析成整数，会让解析后的类型变得不确定，可能导致应用程序出现错误。

eg：` {x: 1, y: 1.0, z: 1.0 } `，这段输入难道解析为1个int，2个double吗？

<br>

Q：bin、ei、eL、es 中的type的作用？  
A：在开发的过程中，经常出现一些简单值需要类型的情况，比如：强调一个字符串是正则表达式，强调一个字符串是代码，强调一个long是时间戳。内置带标签的int32、int64和string对于业务是很友好的。

<br>

Q：为什么日期时间（DateTime）不直接支持 ISO8601格式的字符串？  
A：表面上看，支持DateTime似乎很简单，实则不然。在最初设计Dson的时候，是考虑过内置一个时间格式的，但尝试后放弃了，有这么些原因：

1. ISO8601时间格式的可能性太多，不是简单的两三种情况 -- ISO8061的规范可能都超过了Dson的规范。
2. 我认为ISO8601时间格式的可读性并不好，因为经常缺胳膊少腿，尤其是秒之后的部分，我还要去数小数点后有几位？？？
3. 时区的表达方式太多，Z，+8，+08:00，+08:00:00，我就觉得最多 ±HH:mm 和 ±HH:mm:ss 两种格式就足够了。
4. 时间的表达方式和存储格式与业务很是相关，一旦要支持就需要考虑业务需求，比如：某个部分是否可不输入，考虑这些会引入额外的复杂度，且难以让所有人满意。

基于上面存在的问题，在提供新的时间结构体的时候，加强了约束，不支持ISO8601那种随意的写法，我们将时间的各个部分拆分输入，
且每个部分的格式很是限定。  
其实，引用(ref)和日期时间对于Dson而言都不是必须的，用户可以简单地定义object或array来实现es、eL、es、ref、dt所实现的东西，
但考虑到这些情况极其常见，内置支持会极大方便使用。

PS：一个很好的编程指导是：*简单很重要，而严格的输入能保持简单性*。

<br>

Q：为什么 ref 不是元组？  
A：因为我们提供的引用数据结构较为复杂，导致存在较多的可选项，不像 ei、eL、es那般确定，因此不能使用固定结构的元组来进行解析。  
取而代之的是，我们提供了 @ref localId
这样的支持，因为大多数情况下，用户都是引用文件内的内容，因此支持单个值的快捷写法即可满足日常需求。  
另外，namespace + localId 这种通常只有程序使用Dson的情况下才会出现，因此不需要提供简单的书写方式。  
另外，在我们支持了单值和结构体方式的情况下，再去支持第三种方式的话是不明智的，这样用户的使用复杂度会攀升。

<br>

Q：二进制(bin)的编码选择？  
A：在最开始的时候选择的是Base64编码，但Base64的可读性很差，而设计DSON文本格式的目的就是为了可读和可操作，因此Base64不是个好选择；
在二进制(01)和16进制的选择中，我们选择了16进制，因为16进制需要的字符更少，且表达力足够。  
PS：Dson是有二进制存储格式的，因此在传输效率有要求的场合，使用二进制格式传输更为高效。

Q：为什么header不写在对象外面？写在外面似乎格式更加一致？  
A：用户手写倒是方便，但程序读写就很麻烦了。 header和data连续写入，object的内容更加内聚，截取数据更加容易，readr和writer也更容易实现。
一个很好的类比是网络数据包的封包，网络数据包一般分为 header和data 两部分，但整体是一个数据包，而不是两个独立的部分。

<br>

Q：为什么不支持换行代替空格缩进？  
A：有两个原因：

1. 容易和行首规则冲突，当下一行是合并行的时候容易导致混乱。
2. 必须输入空格，可使得我们手动合并到上一行时仍保持正确性。

<br>

Q：为什么有效内容行必须连字符( - )开头呢？顶层对象为什么也要加呢？  
A：我们需要明确的开始标记，不仅为了解析，也为了可读，不可见的空格这种很容易造成混乱；在新的规范下，-开头可以保持行首长度的一致性。




-----
PS：这其实就是从我设计过程中笔记的一部分。