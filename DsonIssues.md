# Dson设计中的一些反思

Q：Dson是什么？  
A：Dson是JSON和Bson的改进，其中'D'的含义是'Data'的意思，Dson是自解释的数据对象。

Q：为什么创建Dson？  
A：在设计Dson之前，我也设计了序列化组件，也可以很好的工作；但后来在进行一些扩展的时候发现很难受，代码写得很不顺，思来想去，
发现是因为之前的Reader和Writer干的事情太多了，既在处理二进制的编码问题，又在处理业务层的对象编解码需求，如：读写替换、随机读。

简单说就是：**在二进制与Object之间少了一层中间层描述**。  
创建Dson之后，读对象需要两个Reader，写对象需要两个Writer，但代码变得清晰了，扩展性也更好了。

Q：Dson的主要目的？  
A：现在的Dson有3个主要目的：

1. 精确的序列化
2. 可转换为其它数据格式的中间层数据结构，使得业务只需要编码为Dson，而不需要写更多的Codec
3. 配置文件 -- 最初仅仅是期望能输出为可读的文本，可从文本中读取

<br>

Q：为什么要像Json一样，顶层必须是object或array，而不能直接写内容？  
A：这与引用的支持有关，引用可以很好的实现配置复用和减少嵌套；而被引用的对象最好都放置在顶层，这可以降低复杂度，所以我们的顶层上下文其实是一个数组。

<br>

Q：为什么数字的解析默认只有double？  
A：*确定性的解析结果很重要*。浮点数可能恰好是一个整数，一个值，一会儿解析成浮点数，一会儿解析成整数，会让解析后的类型变得不确定，从而导致应用程序出现错误。

eg：` {x: 1, y: 1.0, z: 1.0 } `，这段输入难道解析为1个int，2个double吗？

Q：为什么 NaN，Infinity 这些特殊数值也要加类型标记？  
A：如果只是要求字符串在处理其它类型的特殊值时加引号，扩展特殊值时将产生兼容性问题；另外，要处理的特殊值过多时，将难以快速确定是否要加引号（要记忆的过多），从而可能导致兼容性问题。
每一类的特殊输入时都应该声明类型，才能保持解析的精确性和保证良好的扩展性，也可以减轻字符串的解析压力和书写难度。

Q：为什么科学计数法也要求加类型了？  
A：有两个原因：

1. 科学计数法的匹配效率较低
2. 使用科学计数法的频次不高 -- 这是一个假设

要求科学计数法也加类型，可以很好的降低解析的复杂度，和提高解析效率；
Dson的全局指导是：一旦你想以某种特殊形式输入一个值，都应该显式声明这个值的类型。

Q：为什么浮点数不支持16进制和2进制？只有number类型的脚本语言怎么办？  
A：浮点数的16进制格式并不容易书写，可读性也较低 -- 不过16进制可以有更好的精度。  
对于只有number类型的脚本语言，如果需要使用16进制输入整数，也请在文本中声明为int32或int64类型。

PS: dson的底层实现并未限制使用16进制，如果你能正确书写，且语言本身支持的话，是可以正确解析的。

<br>

Q：为什么要支持 ei、eL、es 三个带标签的基础值类型？  
A：从数据结构的完备性上讲，支持基础值类型，array，object就足够了，因为用户可以通过array和object实现任意的扩展。
Dson最初是为序列化设计的，这三个类型也正是诞生于序列化需要；int32/int64/string的问题在于只能表达存储方式，
不能记录**业务目的**；object由于有className，因而在一定程度上是能表达业务的；

当我们使用了不同的序列化工具或者数据库时，经常需要做适配，比如将一个int64字段转换为对应数据库的时间戳类型。
适配这事干多了，就有点不愿意干了，如果有一套中间层数据结构来完成和其它数据结构的适配，业务层就可以不关心数据库提供的数据类型，
ei、eL、es中的type就是来标记我们的业务目的，因此你可以通dson转换为其它数据结构。

es对于扩展很有帮助，也许会出现真香定律：**es真香！！！**

Q：为什么要支持 es 的value为null？  
A：最初提供ExtString时没有考虑这个问题，禁止了value为null；但在实现codec的时候发现一个问题：
如果禁止value为null，那么业务层想表达value为null时，只能让ExtString整个对象为null，
但这样会导致信息丢失，ExtString的type丢失了，因此底层需要支持value为null。  
PS：普通的String不存在这个问题，因为不存在额外的信息。

<br>

Q：为什么日期时间（DateTime）不直接支持 ISO8601格式的字符串？  
A：表面上看，支持DateTime似乎很简单，实则不然。在最初设计Dson的时候，是考虑过内置一个时间格式的，但尝试后放弃了，有这么些原因：

1. ISO8601时间格式的可能性太多，不是简单的两三种情况 -- ISO8061的规范可能都超过了Dson的规范。
2. 我认为ISO8601时间格式的可读性并不好。
    1. 经常缺胳膊少腿，长度不统一，尤其是秒之后的部分，我还要去数小数点后有几位？？？。
    2. 字符串太长，T和± 符号的加入导致可读性下降。
3. 时间的表达方式与存储格式和业务很是相关，一旦要支持就需要考虑业务需求，比如：某个部分是否可不输入，考虑这些会引入额外的复杂度，且难以让所有人满意。

基于上面存在的问题，在提供新的时间结构体的时候，加强了约束，不支持ISO8601那种随意的写法，我们将时间的各个部分拆分输入，
且每个部分的格式很是限定。  
你可能觉得dson的时间输入有点繁琐，但我们使用日期时间的频次并不高，严格的格式和可选的输入是有益的。

PS：

1. 一个很好的编程指导是：*简单很重要，而严格的输入能保持简单性*。
2. Dson最终选择了支持时间，不是因为日期时间是必须的，而是用户封装日期时间将在语法上遇见不便。
3. ISO8601的复杂度来源于要将大量的信息集中显示。
4. 时区最终支持了多种输入方式，因为在多数情况下，我们都只精确到小时，因此允许简写。

<br>

Q：为什么默认不解析的引用的情况下，还提供了引用数据结构？  
A：引用这个东西逃不了。用于单纯的配置文件时，能引用公共的配置是很方便的；用于大量对象管理的时候，引用更是少不了。
作者是游戏开发者，经常利用编辑器导出文件，这些文件中包含了大量的对象，而且是存在引用关系的。  
但是！什么时候解析引用，以及如何解析引用是应用层决定的，才能保持好的扩展。因此，Dson只设计数据结构，而默认不解析。

Q：为什么 ref 不是元组？  
A：因为我们提供的引用数据结构较为复杂，导致存在较多的可选项，不像 ei、eL、es那般确定，因此不能使用固定结构的元组来进行解析。  
取而代之的是，我们提供了 @ref localId
这样的支持，因为大多数情况下，用户都是引用文件内的内容，因此支持单个值的快捷写法即可满足日常需求。  
另外，namespace + localId 这种通常只有程序使用Dson的情况下才会出现，因此不需要提供简单的书写方式。  
另外，在我们支持了单值和结构体方式的情况下，再去支持第三种方式的话是不明智的，这样用户的使用复杂度会攀升。

<br>

Q：二进制(bin)的编码选择？  
A：在最开始的时候选择的是Base64编码，但Base64的可读性很差，而设计DSON文本格式的目的就是为了可读和可操作，因此Base64不是个好选择；
在二进制(01)和16进制的选择中，我们选择了16进制，因为16进制需要的字符更少，且表达力足够。  
PS：Dson是有二进制存储格式的，因此在传输效率有要求的场合，使用二进制格式传输更为高效。

<br>

Q：变量可以很好的支持配置复用，为什么不像别的配置文件那样支持*变量*？  
A：变量是把双刃剑。引入变量实际上就是让配置文件变为脚本语言，这会让文本的解析变得十分复杂；另外，配置文件去干编程语言干的事情，我认为不太明智，这会限制语言层的扩展。

<br>

Q：为什么之前不支持换行符代替空格分割label和元素，而现在又支持了呢？  
A：之前不支持是从程序的角度考虑的，这可以保证正确性和缩进格式无关。但后来写了一段时间的dson后，
发现写@ss长文本的时候，通常习惯换行开始写（有利于排版），但容易忘记@ss后的空格，便意识到这个设计似乎有点反人类。

**所见即所得是人的思维定势**，人习惯于看见的是什么样的，就认为是什么样的；眼睛认为是分开的，就应该是分开的。
如果程序的规则不符合人的思维定势，就很难以使用；所以程序的终极目标之一就是：所见即所得。

*换行是明显的分隔符*，如果换行起不到换行的作用，也起不到分隔的作用，那就是很糟糕的规则；
空格只有用在可见字符之间是很明显的分隔符，用在行尾是看不见的，因此不应该使用行尾空格制定规范 --
我就不喜欢Markdown这一点。  
所以，我修改了token的解析规则，换行符可以用于分隔label和对应的元素。

PS: 图形程序和文本程序，尤其要注意“所见即所得”这条指导。

<br>

Q：为什么header不写在对象外面？写在外面似乎格式更加一致？  
A：用户手写倒是方便，但程序读写就很麻烦了。 header和data连续写入，object的内容更加内聚，截取数据更加容易，readr和writer也更容易实现。
一个很好的类比是网络数据包的封包，网络数据包一般分为 header和data 两部分，但整体是一个数据包，而不是两个独立的部分。

<br>

Q：行首的选择？  
A：选择行首需要满足以下条件：

1. 足够显眼，能强调差异。
2. 足够平淡，不能干扰阅读。
3. 书写方便。
4. 最好还能有一定的语义暗示(表意性)。

三个及以上字符不考虑，输入麻烦，占排版也较多；两个字符是可以的，但后来发现单个字符输入最方便，也更方便tab缩进。  
数字和字母不能做行首，很容易干扰阅读，只能选择不具含义的字符；

---

## Codec

Q：为什么Codec模块从Dson项目中移除了？  
A：Dson和Dson-Codec本就是从我的Commons模块中迁移出来的，Dson做到无依赖是比较容易的，但Codec与Commons的基础组件之间有较多的依赖，
Codec放在Dson中会导致复杂的包依赖，既不利于我维护，也不利于他人阅读。

Q：Dson打印的大量的@i、@L、@f能不能省掉？  
A：默认情况下int32/int64/float都是需要打印类型以确保精确解析的；但在实现自己的codec的时候，如果存在对应的Class，通常可以省去类型信息。