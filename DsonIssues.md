# Dson设计中的一些反思

Q: 行首的选择？  
A：

1. 足够显眼，能强调差异。
2. 足够平淡，不能干扰阅读。
3. 书写方便。
4. 最好还能有一定的语义暗示(表意性)。

三个及以上字符不考虑，输入麻烦，占排版也较多；  
数字和字母不能做行首，很容易干扰阅读，只能选择不具含义的字符；

<br>

Q：为什么要像Json一样，顶层必须是object或array，而不能直接写内容？  
A：这与引用的支持有关，引用可以很好的实现配置复用和减少嵌套；而被引用的对象最好都放置在顶层，这可以降低复杂度，所以我们的顶层上下文其实是一个数组。


<br>

Q：为什么数字的解析默认只有double？  
A：*确定性的解析结果很重要*。浮点数可能恰好是一个整数，一个值，一会儿解析成浮点数，一会儿解析成整数，会让解析后的类型变得不确定，从而导致应用程序出现错误。

eg：` {x: 1, y: 1.0, z: 1.0 } `，这段输入难道解析为1个int，2个double吗？

<br>

Q：为什么要支持 ei、eL、es 三个带标签的基础值类型？  
A：从数据结构的完备性上讲，支持基础值类型，array，object就足够了，因为用户可以通过array和object实现任意的扩展。
Dson最初是为序列化设计的，这三个类型也正是诞生于序列化需要；int32/int64/string的问题在于只能表达存储方式，
不能记录**业务目的**；object由于有className，因而在一定程度上是能表达业务的；

当我们使用了不同的序列化工具或者数据库时，经常需要做适配，比如将一个int64字段转换为对应数据库的时间戳类型。
适配这事干多了，就有点不愿意干了，如果有一套中间层数据结构来完成和其它数据结构的适配，业务层就可以不关心数据库提供的数据类型，
ei、eL、es中的type就是来标记我们的业务目的，因此你可以通dson转换为其它数据结构。

也许会出现真香定律：**es真香！！！**

<br>

Q：为什么日期时间（DateTime）不直接支持 ISO8601格式的字符串？  
A：表面上看，支持DateTime似乎很简单，实则不然。在最初设计Dson的时候，是考虑过内置一个时间格式的，但尝试后放弃了，有这么些原因：

1. ISO8601时间格式的可能性太多，不是简单的两三种情况 -- ISO8061的规范可能都超过了Dson的规范。
2. 我认为ISO8601时间格式的可读性并不好。
    1. 经常缺胳膊少腿，长度不统一，尤其是秒之后的部分，我还要去数小数点后有几位？？？。
    2. 字符串太长，T和± 符号的加入导致可读性下降。
3. 时区的表达方式太多，Z，+8，+08:00，+08:00:00，我就觉得最多 ±HH:mm 和 ±HH:mm:ss 两种格式就足够了。
4. 时间的表达方式与存储格式和业务很是相关，一旦要支持就需要考虑业务需求，比如：某个部分是否可不输入，考虑这些会引入额外的复杂度，且难以让所有人满意。

基于上面存在的问题，在提供新的时间结构体的时候，加强了约束，不支持ISO8601那种随意的写法，我们将时间的各个部分拆分输入，
且每个部分的格式很是限定。  
你可能觉得dson的时间输入有点繁琐，但我们使用日期时间的频次并不高，严格的和支持可选的输入是有益的。

PS：

1. 一个很好的编程指导是：*简单很重要，而严格的输入能保持简单性*。
2. Dson最终选择了支持时间，不是因为日期时间是必须的，而是用户封装日期时间将在语法上遇见不便。

<br>

Q：为什么默认不解析的引用的情况下，还提供了引用数据结构？
A：引用这个东西逃不了。用于单纯的配置文件时，能引用公共的配置是很方便的；用于大量对象管理的时候，引用更是少不了。
作者是游戏开发者，经常利用编辑器导出文件，这些文件中包含了大量的对象，而且是存在引用关系的。

Q：为什么 ref 不是元组？  
A：因为我们提供的引用数据结构较为复杂，导致存在较多的可选项，不像 ei、eL、es那般确定，因此不能使用固定结构的元组来进行解析。  
取而代之的是，我们提供了 @ref localId
这样的支持，因为大多数情况下，用户都是引用文件内的内容，因此支持单个值的快捷写法即可满足日常需求。  
另外，namespace + localId 这种通常只有程序使用Dson的情况下才会出现，因此不需要提供简单的书写方式。  
另外，在我们支持了单值和结构体方式的情况下，再去支持第三种方式的话是不明智的，这样用户的使用复杂度会攀升。

<br>

Q：二进制(bin)的编码选择？  
A：在最开始的时候选择的是Base64编码，但Base64的可读性很差，而设计DSON文本格式的目的就是为了可读和可操作，因此Base64不是个好选择；
在二进制(01)和16进制的选择中，我们选择了16进制，因为16进制需要的字符更少，且表达力足够。  
PS：Dson是有二进制存储格式的，因此在传输效率有要求的场合，使用二进制格式传输更为高效。

<br>

Q：为什么header不写在对象外面？写在外面似乎格式更加一致？  
A：用户手写倒是方便，但程序读写就很麻烦了。 header和data连续写入，object的内容更加内聚，截取数据更加容易，readr和writer也更容易实现。
一个很好的类比是网络数据包的封包，网络数据包一般分为 header和data 两部分，但整体是一个数据包，而不是两个独立的部分。

<br>

Q：为什么不支持换行代替空格缩进？  
A：有两个原因：

1. 容易和行首规则冲突，当下一行是合并行的时候容易导致混乱。
2. 必须输入空格，可使得我们手动合并到上一行时仍保持正确性。

<br>

-----
PS：这其实就是从我设计过程中笔记的一部分。