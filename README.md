# Dson

Dson是一个有点奇怪的配置文件格式，但这也许会成为流行的配置文件格式。

Dson同时设计了二进制和文本格式，二进制用于网络传输，文本格式用于配置文件； 另外，还提供了数字表示字段的高压缩率二进制版本。
Dson核心包不提供Dson到对象的编解码实现，只包含Dson的二进制流和文本解析实现；会在Codec模块提供一个简单的编解码实现。
Dson支持复杂的数据结构，同时还设计了对象头，因此实现自己的Codec是很容易的。

Dson最初是为序列化而创建的，但我们在这里只讨论文本格式，二进制格式详见[Dson二进制流](https://github.com/hl845740757/Dson/blob/dev/DsonBinary.md)。  
另外，Dson的一些设计可能与你期望的不同，为避免频繁提问，我将一些设计理由进行了整理，见[Dson设计过程中的一些反思](https://github.com/hl845740757/Dson/blob/dev/DsonIssues.md)。

## Dson文本格式的目标

1. 精确性
2. 易于编写和阅读
3. 易于维护
4. 易于扩展

PS：Dson的文本格式从设计到最终实现大概1个月时间，尝试了多个版本的语法和行首，现版本我认为还是达到了目标，在缺乏编辑器的情况下，手写和阅读的体验都还不错。

## Dson的特性

1. 支持注释
2. 支持行合并，长内容行随意切割
3. 支持纯文本字段，所见即所得，可摆脱转义字符
4. 引号不是必须的
5. 支持对象头，可自定义对象头内容
6. 支持类型传递，适用数组元素和Object
7. 支持读取Json

## 行首

Dson最特殊的地方在于行的构成，在Dson中，每一行由**行首**和**内容**构成。  
行首固定两个字符，行首与内容之间通过一个空格分隔，从第4个字符开始是内容。  
行首目前共4类，如下表：

| 标签  |                  | 含义                    | 格式或示例           |
|-----|------------------|-----------------------|-----------------|
| #   | comment          | 注释行，当前行有效             | # 这是一行注释        |
| --  | append line      | 普通行，该行与上一行独立，保留上一行换行符 | -- 这是新的一行       |
| -\| | append           | 合并行，该行与上一行合并，忽略上一行换行符 | -\| 上一行太长了，换行继续 |
| ->  | append text line | 独立行，用于纯文本模式下添加新行      | -> 这是文本中的一个新行   |

从功能上讲，行首只分两类，append 和 appendLine，因为行首解决的问题就只是行的拆分问题。  
PS：挑选行首字符也蛮困难的，既要对阅读影响小，还要让人容易接受其语义暗示，还要敲着方便。。。

## 类型

与json相同，{} 用于表达一个对象，[] 用于表达一个数组；不过，**dson还支持对象头**，@{}表示一个对象头数据结构。  
Dson支持的值类型和内置结构体包括：

| 标签  | 类型        | 含义           | 内置结构体                                                                                | 格式或示例                                                                                                         |
|-----|-----------|--------------|--------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| i   | int32     | 32位整型        |                                                                                      | @i 123 <br> @i  0xFF                                                                                          |
| L   | int64     | 64位长整型，大写L   |                                                                                      | @L 123 <br> @L 0xFF                                                                                           |
| f   | float     | 32位浮点数       |                                                                                      | @f 1.0                                                                                                        |
| d   | double    | 64位浮点数       |                                                                                      | @d 1.5  <br> 1.5                                                                                              |
| b   | bool      | bool值        |                                                                                      | @b true <br> true                                                                                             |
|     | string    | 字符串          |                                                                                      | "10"   <br>  abc                                                                                              |
| N   | null      | null，大写N     |                                                                                      | @N null <br> null                                                                                             |
| bin | binary    | 二进制，带类型标签    | {<br> int32 type;<br> byte[] data <br>}                                              | 格式固定二元数组 \[@bin type, data] <br> \[@bin 1, FFFE]                                                              |
| ei  | extInt32  | 带类型标签的int32  | {<br> int32 type;<br> int32 value <br>}                                              | 格式固定二元数组 \[@ei type, value] <br> \[@ei 1,  10086]                                                             |
| eL  | extInt64  | 带类型标签的int64  | {<br> int32 type;<br> int64 value <br>}                                              | 格式固定二元数组 \[@eL type, value] <br> \[@eL 1,  10086]                                                             |
| es  | extString | 带类型标签的string | {<br> int32 type;<br> string value <br>}                                             | 格式固定二元数组 \[@es type, value] <br> \[@es 10, "abcd"]                                                            |
| ref | reference | 引用           | {<br> string namespace;<br> string localId;<br> int32 type; <br> int32 policy; <br>} | 格式为单值 '@ref localId' 格式或 object格式 <br/> @ref abcdefg <br> {@ref namespace: wjybxx, localId: abcdefg, type: 0} |
| dt  | datetime  | 日期时间         | { <br>  int64 seconds; <br> int32 nanos;<br> int32 offset;<br> int32 enables; <br> } | 无需引号<br/> {@dt date: 2023-06-17, time: 18:37:00, offset: +08:00, millis: 100}                                 |

## 特殊标签

特殊标签不是真正的类型，而是对类型的修饰，是语法糖，用以简化书写。

| 标签 | 类型                         | 含义                                                                                                 | 格式或示例                                                                                                           |
|----|----------------------------|----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|
| ss | string string <br/> (text) | 纯文本 <br> 1. 不会对字符进行转义，所见即所得 <br/>2. 遇见 -- 独立行行首表示结束 <br/>3. 即可修饰value，**也可修饰key** <br/>4. 相当于特殊的引号 | -- {<br> -- url:  @ss https://github.com/hl845740757 <br> -- , reg: @ss ^\[\u4e00-\u9fa5_a-zA-Z0-9]+$ <br> -- } |

在我自己的笔记中，示例其实比上面两张表复杂，但我实在不想写转义字符和标签，所以示例偷懒了...

## @声明标签

我们可以通过'@label'声明一个元素的类型，一般是修饰下一个元素，元素可以是 key，也可以是value，取决于上下文。  
普通value类型，可在value的前方通过@声明类型， @label 和 value之间通过空白字符分割；object和array则在{}和[]
内声明header，且声明时和外层括号之间无空格。

当 @ 作用于普通值类型和内置简单结构体时，我们称 @ 声明的是其类型；当 @ 作用于 object和array 时，我们称 @ 声明的是对象的头信息。

### Header支持的特殊属性

| 属性名         | 含义                                          | 备注             |
|-------------|---------------------------------------------|----------------|
| clsName     | className的缩写，表达当前对象的类型                      | 可包括内置基础值和内置结构体 | 
| compClsName | componentClassName的缩写，表示数组成员或Object的value类型 | 可包括内置基础值和内置结构体 |
| localId     | 对象本地id，字符串类型                                | 用于支持默认的引用解析    |

## 全局规范：

1. Dson是基于行解析的，行首的空白将被忽略。
2. Dson的每一行由 行首 和 内容构成。
3. \# 表述注释行，# 号仅对当前行有效，不支持行尾注释。
4. \- 表示内容行，行首标签与内容之间至少键入一个空格（且必须是空格），以表达内容的开始。
5. 顶层对象必须是数组或Object，你不可以直接声明一个基础值类型，顶层对象之间可以不使用逗号分隔。
6. @label 格式后必须有一个空格，**换行不可以代替空格**。

## 各种值的规范

### Number系列

1. 普通格式和科学计数法以外的格式，必须声明类型标签
2. int和long值支持16进制写法，以 0x 开头
3. 浮点数支持科学计数法
4. 数字如果包含了不安全字符，需要使用双引号

``` 
    {value: @i 0XFF }
```

### bool值

1. bool 只支持 true 和 false 两个值，且大小写严格，拼写错误将引发错误

### 字符串

1. 可以使用双引号强调值是一个字符串类型
2. 普通无引号字符串只能由安全字符构成，安全字符较多，我们给出不安全字符集。
3. 无引号字符串遇见不安全字符时将判定为结束。
4. 使用双引号时，\ 是转义字符，解析时将对引号进行转义，因此内容中出现双引号时需要转义
5. 在纯文本中，不需要加引号，\ 不是转义字符，所见即所得，遇见 '--' 行首时表示结束。
6. 在纯文本中，每行只有行首标签后的第一个空白字符是缩进，另外 @ss 后也必须有一个空格。
7. 存在一些特殊含义的字符串，用户最好总是使用双引号强调是字符串，否则可能发生兼容性问题。

#### 不安全字符

1. 空白字符
2. dson token字符集：花括号'{}'  、方括号 '[]' 、 逗号'.' 、 冒号':'   、艾特 '@' 、反斜杠 '\'
3. 保留字符集：圆括号 ’()‘ 、单引号 '
4. 特殊含义字符串："true", "false",   "null", "undefine",   "NaN", "Infinity", "-Infinity"

### 二进制

1. 配置格式限定二元组 \[type, data]
2. type限定 0~255
3. data部分使用 **16进制** 编码

### ei、eL、es

1. 配置格式限定二元组 [type, value]
2. type限定int32
3. value部分遵循各自的规范

### ref

1. ref支持两种范式 @ref localId 和 {@ref localId: $localId, namespace: $namespace, type: $type, policy: $policy}
2. ref localId 简写方式适用大多数情况，结构体用于复杂情况。
3. 结构体格式下，localId 和 namespace至少输入一个，其它参数可选。
4. **Dson默认不解析引用**，只存储为ref结构，会提供根据localId的简单解析方法。

```
   {@ref localId: "10001", namespace : global, type: 1 }
   {@ref localId: "10001", namespace : global, type: 1, policy: 1}
```

### dt-日期时间

1. dt只支持标准的结构体样式 {@dt date: yyyy-MM-dd, time: HH:mm:ss, offset: ±HH:mm:ss, millis: $millis, nanos: $nanos}
2. date 部分为 "yyyy-MM-dd" 格式。
3. time 部分为 "HH:mm:ss" 格式，不可省略秒部分。
4. offset 部分为 "±HH:mm" 或 "±HH:mm:ss"  格式，不可以省略正负号。
5. millis 表示精确到毫秒，其值为秒的 毫秒部分。
6. nanos 表示精确到纳秒，其值为秒的 纳秒部分， millis 和 nanos通常只应该出现一个。
7. date 和 time 至少输入一个，其它属性都是可选的。

```
    {@dt date: 2023-06-17, time: 18:37:00}
    {@dt date: 2023-06-17, time: 18:37:00, offset: +08:00}    
    {@dt date: 2023-06-17, time: 18:37:00, offset: +08:00, millis: 100}
    {@dt date: 2023-06-17, time: 18:37:00, offset: +08:00, nanos: 100000000}
```

关于结构体的说明

1. seconds 是纪元时间的秒时间
2. nanos 是时间戳的纳秒部分
3. offset 是时区的秒数
4. enables 记录了用户输入了哪些部分，由掩码构成，后4个比特位有效。
    1. date 的掩码是 1000
    2. time 的掩码是 0100
    3. offset 的掩码是 0010

### object

1. 键值对之间通过 ',' (英文逗号) 分隔。
2. key和value之间通过 ':' (英文冒号)分隔，空格分隔冒号不是必须的，但冒号和value之间建议输入空格。
3. key为字符串类型，适用字符串规范，无特殊字符时可省略双引号，也可以使用 @ss 标签。
4. 声明对象自己的类型时，@和object的 { 之间无空格，即： {@xxxx ，否则将被解释为下一个元素的类型信息。
5. @className时，className和正式内容之间至少键入一个空白字符；@{...}时，后面可以不键入空格，但建议键入。
6. 当声明value的类型时，可通过声明header结构体，并指定 'compClsName' 属性实现。

### array

1. value之间通过 ',' (英文逗号) 分隔。
2. 声明对象自己的类型时，@与array的 [ 之间无空格，即： [@xxxx ，否则将被解释为下一个元素的类型信息。
3. @className时，className和正式内容之间至少键入一个空白字符；@{...}时，后面可以不键入空格，但建议键入。
4. 当声明value的类型时，可通过声明header结构体，并指定 'compClsName' 属性实现。

### header

1. @不可以接空白字符。
2. 当@用于简单声明类型名时，格式为： ”@className “ , className和正式内容之间必须键入一个空格
3. 当@用于声明header结构体时，格式为："@{ ... } "
4. className为字符串类型，适用字符串配置规范。
5. header结构体不可以再内嵌header
6. header没有默认结构体，以允许用户自行扩展。

以下是object声明header的示例

```
    # 不声明header
    { x: 0, y: 0, z: 0 }
    # 只声明ClassName
    {@Vector3 x: 0, y: 0, z: 0 }
    # 声明复杂的header
    {@{clsName: Vector3, localId: 321123} x: 1, y: 1, z: 1} 
```

### 无类型value解析规则

1. 首先去掉value两端的空白字符
2. 如果value首字符为 { ，则按照object解析
3. 如果value首字符为 [ ，则按照array解析
4. 如果value首字符为 "  ，则按照字符串解析
5. 如果value为 true 或 false ，则解析为bool类型
6. 如果value为 null，则解析为null
7. 如果value匹配整数或浮点数(特殊格式不匹配)，则固定解析为double类型。
8. 其它情况下默认解析为String

## 一些好的实践

1. \- 和 # 总是写在行首，顶级对象之间通过空白行分离
2. header的定义要保持简单和简短，避免增加额外的复杂度，
3. key保持简单且长度较小，尽量不产生换行；key尽量遵守一般编程语言变量命名规范。
4. ClassName不要包含特殊字符，使得ClassName总是可以无引号表达。
5. ClassName中通过点号( . )分离，表达不同的命名空间 ，大写开头表自定义类型，基本值类型小写开头。
6. { 和 [ 与正式内容之间总是键入一个空格
7. 字符串尽量使用无引号模式 和 段落模式输入，手写转义是麻烦易出错的工作。

## 文本示例

以下代码来自 DsonTextReaderTest2.java

```
   # 输入文本
   -- {@{clsName: MyClassInfo, guid: 10001, flags: 0}
   --     name: wjybxx,
   --     age: 28,
   --     pos: {@Vector3 x: 0, y: 0, z: 0},
   --     address: [
   --         beijing,
   --         chengdu,
   --     ],
   --     intro: @sss
   -|     我是wjybxx，是一个游戏开发者，Dson是我设计的文档型数据表达法，
   -| 你可以通过github联系到我。
   ->     thanks
   --   , url: @ss https://www.github.com/hl845740757
   --   , time: {@dt date: 2023-06-17, time: 18:37:00,  millis: 100, offset: +08:00}
   -- }
    
   # 测试用例输出
   -- {@{clsName: MyClassInfo, guid: 10001, flags: 0}
   --   name: wjybxx,
   --   age: 28,
   --   pos: {@{clsName: Vector3}
   --     x: 0,
   --     y: 0,
   --     z: 0
   --   },
   --   address: [
   --     beijing,
   --     chengdu
   --   ],
   --   intro: @ss     我是wjybxx，是一个游戏开发者，Dson是我设计的文档型数
   -| 据表达法，你可以通过github联系到我。
   ->     thanks
   -- , url: "https://www.github.com/hl845740757",
   --   time: {@dt date: 2023-06-17, time: 18:37:00, 
   -- millis: 100, offset: +08:00}
   -- }
    
```

## Dson编辑器（缺失）

行首虽然很好的解决了内容拆分的问题，但对新手使用者有一定的干扰，如果有编辑器（和插件）支持的话，行首带来的影响就可以消除。
不过，作者我不是很擅长做这个，暂时无法提供。

## 多语言

作者本人是一个游戏开发者，熟悉JAVA、C#、LUA，后期会提供C#的Dson实现；其它语言可能只能依靠喜欢上Dson的小伙伴们提供。

## 特别鸣谢

这里感谢MongoDB的Bson团队，Bson源代码对于我实现Dson起到了很大的帮助作用。

## 与其他配置文件格式的比较
