# Dson

Dson是一个有点奇怪的配置文件格式，但这也许会成为流行的配置文件格式。

Dson同时设计了二进制和文本格式，二进制用于网络传输，文本格式用于配置文件； 另外，还提供了数字表示字段的高压缩率二进制版本。
Dson核心包不提供Dson到对象的编解码实现，只包含Dson的二进制流和文本解析实现；会在Codec模块提供一个简单的编解码实现。
Dson支持复杂的数据结构，同时还设计了对象头，因此实现自己的Codec是很容易的。

Dson最初是为序列化而创建的，但我们在这里只讨论文本格式，二进制格式详见[Dson二进制流](https://github.com/hl845740757/Dson/blob/dev/DsonBinary.md)。

## Dson文本格式的目标

1. 精确性
2. 易于编写和阅读
3. 易于维护
4. 易于扩展

## Dson的特性

1. 支持注释
2. 支持行合并，长内容行随意切割
3. 支持纯文本字段，所见即所得，可摆脱转义字符
4. 引号不是必须的
5. 支持对象头，可自定义对象头内容
6. 支持类型传递，适用数组元素和Object
7. 支持读取Json
8. 支持引用，可扩展解析规则

## 行首

Dson最特殊的地方在于行的构成，在Dson中，每一行由**行首**和**内容**构成。  
行首固定两个字符，行首与内容之间通过一个空格分隔，从第4个字符开始是内容。  
行首目前共4类，如下表：

| 标签  |                  | 含义                    | 格式或示例           |
|-----|------------------|-----------------------|-----------------|
| #   | comment          | 注释行，当前行有效             | # 这是一行注释        |
| --  | append line      | 普通行，该行与上一行独立，保留上一行换行符 | -- 这是新的一行       |
| -\| | append           | 合并行，该行与上一行合并，忽略上一行换行符 | -\| 上一行太长了，换行继续 |
| ->  | append text line | 独立行，用于纯文本模式下添加新行      | -> 这是文本中的一个新行   |

从功能上讲，行首只分两类，append 和 appendLine，因为行首解决的问题就只是行的拆分问题。  
PS：挑选行首字符也蛮困难的，既要对阅读影响小，还要让人容易接受其语义暗示，还要敲着方便。。。

## 类型

与json相同，{} 用于表达一个对象，[] 用于表达一个数组；不过，**dson还支持对象头**，@{}表示一个对象头数据结构。  
Dson支持的值类型和内置结构体包括：

| 标签  | 类型        | 含义           | 内置结构体                                                                                | 格式或示例                                                                                                         |
|-----|-----------|--------------|--------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| i   | int32     | 32位整型        |                                                                                      | @i 123 <br> @i  0xFF                                                                                          |
| L   | int64     | 64位长整型，大写L   |                                                                                      | @L 123 <br> @L 0xFF                                                                                           |
| f   | float     | 32位浮点数       |                                                                                      | @f 1.0                                                                                                        |
| d   | double    | 64位浮点数       |                                                                                      | @d 1.5  <br> 1.5                                                                                              |
| b   | bool      | bool值        |                                                                                      | @b true <br> true                                                                                             |
|     | string    | 字符串          |                                                                                      | "10"   <br>  abc                                                                                              |
| N   | null      | null，大写N     |                                                                                      | @N null <br> null                                                                                             |
| bin | binary    | 二进制，带类型标签    | {<br> int32 type;<br> byte[] data <br>}                                              | 格式固定二元数组 \[@bin type, data] <br> \[@bin 1, FFFE]                                                              |
| ei  | extInt32  | 带类型标签的int32  | {<br> int32 type;<br> int32 value <br>}                                              | 格式固定二元数组 \[@ei type, value] <br> \[@ei 1,  10086]                                                             |
| eL  | extInt64  | 带类型标签的int64  | {<br> int32 type;<br> int64 value <br>}                                              | 格式固定二元数组 \[@eL type, value] <br> \[@eL 1,  10086]                                                             |
| es  | extString | 带类型标签的string | {<br> int32 type;<br> string value <br>}                                             | 格式固定二元数组 \[@es type, value] <br> \[@es 10, "abcd"]                                                            |
| ref | reference | 引用           | {<br> string namespace;<br> string localId;<br> int32 type; <br> int32 policy; <br>} | 格式为单值 '@ref localId' 格式或 object格式 <br/> @ref abcdefg <br> {@ref namespace: wjybxx, localId: abcdefg, type: 0} |

## 特殊标签

特殊标签不是真正的类型，而是对类型的修饰，是语法糖，用以简化书写。

| 标签 | 类型           | 含义                                                                                                                 | 格式或示例                                                                                                           |
|----|--------------|--------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|
| ss | text         | 纯文本 <br> 1. 不会对字符进行转义，所见即所得 <br/>2. 遇见 -- 独立行行首表示结束 <br/>3. 即可修饰value，**也可修饰key** <br/>4. 相当于特殊的引号  <br>配置复杂字符串的神器 | -- {<br> -- url:  @ss https://github.com/hl845740757 <br> -- , reg: @ss ^\[\u4e00-\u9fa5_a-zA-Z0-9]+$ <br> -- } |
| sv | string value | 用于无符号字符串，从第一个非空白字符开始，直到遇见空白字符或**逗号**，或 对象结束符 }、数组结束符 ] 结束                                                          | -- @sv 1970-01-01T12:00:00                                                                                      |

在我自己的笔记中，示例其实比上面两张表复杂，但我实在不想写转义字符和标签，所以示例偷懒了...

## @声明标签

我们可以通过'@label'声明一个元素的类型，一般是修饰下一个元素，元素可以是 key，也可以是value，取决于上下文。  
普通value类型，可在value的前方通过@声明类型， @label 和 value之间通过空白字符分割；object和array则在{} 和 [] 内声明header，且声明时
**和外层括号之间无空格**。

当 @ 作用于普通值类型和内置简单结构体时，我们称 @ 声明的是其类型；当 @ 作用于 object 和 array 时，我们称 @
声明的是对象的头信息，在object 和 array下可声明更多的属性。我们以object为例，以下是三种情况：

```
    # 不声明header
    { x: 0, y: 0, z: 0 }
    # 只声明ClassName
    {@Vector3 x: 0, y: 0, z: 0 }
    # 声明复杂的header
    {@{clsName: Vector3, localId: 321123} x: 1, y: 1, z: 1} 
```

### Header支持的特殊属性

| 属性名         | 含义                                          | 备注             |
|-------------|---------------------------------------------|----------------|
| clsName     | className的缩写，表达当前对象的类型                      | 可包括内置基础值和内置结构体 | 
| compClsName | componentClassName的缩写，表示数组成员或Object的value类型 | 可包括内置基础值和内置结构体 |
| localId     | 对象本地id，字符串类型                                | 通常用于解析引用       |

## 全局规范：

1. Dson是基于行解析的，行首的空白将被忽略。
2. Dson的每一行由 行首 和 内容构成。
3. \# 表述注释行，# 号仅对当前行有效，不支持行尾注释。
4. \- 表示内容行，行首标签与内容之间至少键入一个空格（且必须是空格），以表达内容的开始。
5. 顶层对象必须是数组或Object，你不可以直接声明一个基础值类型，顶层对象之间可以不使用逗号分隔。
6. @label 格式后必须有一个空格，**换行不可以代替空格**。

## 各种值的规范

### Number系列

1. 普通格式和科学计数法以外的格式，必须声明类型标签
2. int和long值支持16进制写法，以 0x 开头
3. 浮点数支持科学计数法
4. 数字如果包含了不安全字符，需要使用双引号

``` 
    -- {value: @i 0XFF }
```

### bool值

1. bool 只支持 true 和 false 两个值，且大小写严格，拼写错误将引发错误

### 字符串

1. 可以使用双引号强调值是一个字符串类型
2. 普通无引号字符串只能由安全字符构成，安全字符较多，我们给出不安全字符集。
3. 无引号字符串遇见不安全字符时将判定为结束。
4. 使用双引号时，\ 是转义字符，解析时将对引号进行转义，因此内容中出现双引号时需要转义
5. 在纯文本中，不需要加引号，\ 不是转移字符，所见即所得，遇见 '--' 行首时表示结束。
6. 在纯文本中，每行只有行首标签后的第一个空白字符是缩进，另外 @ss 后也必须有一个空格。
7. 存在一些特殊含义的字符串，用户最好总是使用双引号强调是字符串，否则可能发生兼容性问题。

#### 不安全字符

1. 空白字符
2. dson token字符集：花括号'{}'  、方括号 '[]' 、 逗号'.' 、 冒号':'   、艾特 '@' 、反斜杠 '\'
3. 保留字符集：圆括号 ’()‘ 、单引号 '
4. 特殊含义字符串："true", "false",   "null", "undefine",   "NaN", "Infinity", "-Infinity"

### 二进制

1. 配置格式限定二元组 \[type, data]
2. type限定 0~255
3. data部分使用 **16进制** 编码

### ei、eL、es

1. 配置格式限定二元组 [type, value]
2. type限定int32
3. value部分遵循各自的规范

### ref

1. ref支持两种范式 @ref localId 和 {@ref localId: $localId, namespace: $namespace, type: $type ...}
2. ref localId 简写方式适用大多数情况。
3. **Dson默认不解析引用**，只存储为ref结构，会提供根据localId的简单解析方法。

### object

1. 键值对之间通过 ',' (英文逗号) 分隔。
2. key和value之间通过 ':' (英文冒号)分隔，空格分隔冒号不是必须的，但建议输入空格。
3. key为字符串类型，适用字符串规范，无特殊字符时可省略双引号
4. 声明对象自己的类型时，@和object的 { 之间无空格，即： {@xxxx ，否则将被解释为下一个元素的类型信息。
5. @className时，className和正式内容之间至少键入一个空白字符；@{...}时，后面可以不键入空格，但建议键入。
6. 当声明value的类型时，可通过声明header结构体，并指定 'compClsName' 属性实现。

### array

1. value之间通过 ',' (英文逗号) 分隔。
2. 声明对象自己的类型时，@与array的 [ 之间无空格，即： [@xxxx ，否则将被解释为下一个元素的类型信息。
3. @className时，className和正式内容之间至少键入一个空白字符；@{...}时，后面可以不键入空格，但建议键入。
4. 当声明value的类型时，可通过声明header结构体，并指定 'compClsName' 属性实现。

### header

1. @不可以接空白字符。
2. 当@用于简单声明类型名时，格式为： ”@className “ , className和正式内容之间必须键入一个空格
3. 当@用于声明header结构体时，格式为："@{ ... } "
4. className为字符串类型，适用字符串配置规范。
5. header结构体不可以再内嵌header
6. header没有默认结构体，以允许用户自行扩展。

### 无类型value解析规则

1. 首先去掉value两端的空白字符
2. 如果value首字符为 { ，则按照object解析
3. 如果value首字符为 [ ，则按照array解析
4. 如果value首字符为 "  ，则按照字符串解析
5. 如果value为 true 或 false ，则解析为bool类型
6. 如果value为 null，则解析为null
7. 如果value匹配整数或浮点数(特殊格式不匹配)，则固定解析为double类型。
8. 其它情况下默认解析为String

## 一些好的实践

1. \- 和 # 总是写在行首，顶级对象之间通过空白行分离
2. header的定义要保持简单和简短，避免增加额外的复杂度，
3. key保持简单且长度较小，尽量不产生换行；key尽量遵守一般编程语言变量命名规范。
4. ClassName不要包含特殊字符，使得ClassName总是可以无引号表达。
5. ClassName中通过点号( . )分离，表达不同的命名空间 ，大写开头表自定义类型，基本值类型小写开头。
6. { 和 [ 与正式内容之间总是键入一个空格
7. 字符串尽量使用无引号模式 和 段落模式输入，手写转义是麻烦易出错的工作。

## 文本示例

```
    -- {@{clsName: MyClassInfo, localId: 10001, type: 0}
    --     name: wjybxx,
    --     age: 28,
    --     pos: {@Vector3 x: 0, y: 0, z: 0},
    --     address: [
    --         beijng,
    --         chengdu,
    --     ],
    --     intro: @ss 
    -|     我是wjybxx，是一个游戏开发者，Dson是我设计的文档型数据表达法，
    -| 你可以通过github联系到我。
    ->     thanks
    --   , url: @ss https://www.github.com/hl845740757
    -- }
```

## Dson编辑器（缺失）

行首虽然很好的解决了内容拆分的问题，但对新手使用者有一定的干扰，如果有编辑器（和插件）支持的话，行首带来的影响就可以消除。
不过，作者我不是很擅长做这个，暂时无法提供。

## 多语言

作者本人是一个游戏开发者，熟悉JAVA、C#、LUA，后期会提供C#的Dson实现；其它语言可能只能依靠喜欢上Dson的小伙伴们提供。

## 特别鸣谢

这里感谢MongoDB的Bson团队，Bson源代码对于我实现Dson起到了很大的帮助作用。

## 与其他配置文件格式的比较
